{"id":"../node_modules/react-json-tree/lib/JSONNestedNode.js","dependencies":[{"name":"/Users/hcltmac/Desktop/amis-editor/package.json","includedInParent":true,"mtime":1607395305037},{"name":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/package.json","includedInParent":true,"mtime":1606632417000},{"name":"react","loc":{"line":8,"column":44},"parent":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONNestedNode.js","resolved":"/Users/hcltmac/Desktop/amis-editor/node_modules/react/index.js"},{"name":"prop-types","loc":{"line":10,"column":48},"parent":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONNestedNode.js","resolved":"/Users/hcltmac/Desktop/amis-editor/node_modules/prop-types/index.js"},{"name":"./JSONArrow","loc":{"line":12,"column":48},"parent":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONNestedNode.js","resolved":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONArrow.js"},{"name":"./getCollectionEntries","loc":{"line":14,"column":59},"parent":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONNestedNode.js","resolved":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/getCollectionEntries.js"},{"name":"./JSONNode","loc":{"line":16,"column":47},"parent":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONNestedNode.js","resolved":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONNode.js"},{"name":"./ItemRange","loc":{"line":18,"column":48},"parent":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/JSONNestedNode.js","resolved":"/Users/hcltmac/Desktop/amis-editor/node_modules/react-json-tree/lib/ItemRange.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _JSONArrow = _interopRequireDefault(require(\"./JSONArrow\"));\n\nvar _getCollectionEntries = _interopRequireDefault(require(\"./getCollectionEntries\"));\n\nvar _JSONNode = _interopRequireDefault(require(\"./JSONNode\"));\n\nvar _ItemRange = _interopRequireDefault(require(\"./ItemRange\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction isRange(rangeOrEntry) {\n  return rangeOrEntry.to !== undefined;\n}\n\nfunction renderChildNodes(props, from, to) {\n  var nodeType = props.nodeType,\n      data = props.data,\n      collectionLimit = props.collectionLimit,\n      circularCache = props.circularCache,\n      keyPath = props.keyPath,\n      postprocessValue = props.postprocessValue,\n      sortObjectKeys = props.sortObjectKeys;\n  var childNodes = [];\n  (0, _getCollectionEntries[\"default\"])(nodeType, data, sortObjectKeys, collectionLimit, from, to).forEach(function (entry) {\n    if (isRange(entry)) {\n      childNodes.push( /*#__PURE__*/_react[\"default\"].createElement(_ItemRange[\"default\"], _extends({}, props, {\n        key: \"ItemRange--\".concat(entry.from, \"-\").concat(entry.to),\n        from: entry.from,\n        to: entry.to,\n        renderChildNodes: renderChildNodes\n      })));\n    } else {\n      var key = entry.key,\n          value = entry.value;\n      var isCircular = circularCache.indexOf(value) !== -1;\n      childNodes.push( /*#__PURE__*/_react[\"default\"].createElement(_JSONNode[\"default\"], _extends({}, props, {\n        postprocessValue: postprocessValue,\n        collectionLimit: collectionLimit\n      }, {\n        key: \"Node--\".concat(key),\n        keyPath: [key].concat(_toConsumableArray(keyPath)),\n        value: postprocessValue(value),\n        circularCache: [].concat(_toConsumableArray(circularCache), [value]),\n        isCircular: isCircular,\n        hideRoot: false\n      })));\n    }\n  });\n  return childNodes;\n}\n\nfunction getStateFromProps(props) {\n  // calculate individual node expansion if necessary\n  var expanded = props.shouldExpandNode && !props.isCircular ? props.shouldExpandNode(props.keyPath, props.data, props.level) : false;\n  return {\n    expanded: expanded\n  };\n}\n\nvar JSONNestedNode = /*#__PURE__*/function (_React$Component) {\n  _inherits(JSONNestedNode, _React$Component);\n\n  var _super = _createSuper(JSONNestedNode);\n\n  function JSONNestedNode(props) {\n    var _this;\n\n    _classCallCheck(this, JSONNestedNode);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClick\", function () {\n      if (_this.props.expandable) {\n        _this.setState({\n          expanded: !_this.state.expanded\n        });\n      }\n    });\n\n    _this.state = getStateFromProps(props);\n    return _this;\n  }\n\n  _createClass(JSONNestedNode, [{\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      var nextState = getStateFromProps(nextProps);\n\n      if (getStateFromProps(this.props).expanded !== nextState.expanded) {\n        this.setState(nextState);\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var _this2 = this;\n\n      return !!Object.keys(nextProps).find(function (key) {\n        return key !== 'circularCache' && (key === 'keyPath' ? nextProps[key].join('/') !== _this2.props[key].join('/') : nextProps[key] !== _this2.props[key]);\n      }) || nextState.expanded !== this.state.expanded;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          getItemString = _this$props.getItemString,\n          nodeTypeIndicator = _this$props.nodeTypeIndicator,\n          nodeType = _this$props.nodeType,\n          data = _this$props.data,\n          hideRoot = _this$props.hideRoot,\n          createItemString = _this$props.createItemString,\n          styling = _this$props.styling,\n          collectionLimit = _this$props.collectionLimit,\n          keyPath = _this$props.keyPath,\n          labelRenderer = _this$props.labelRenderer,\n          expandable = _this$props.expandable;\n      var expanded = this.state.expanded;\n      var renderedChildren = expanded || hideRoot && this.props.level === 0 ? renderChildNodes(_objectSpread(_objectSpread({}, this.props), {}, {\n        level: this.props.level + 1\n      })) : null;\n\n      var itemType = /*#__PURE__*/_react[\"default\"].createElement(\"span\", styling('nestedNodeItemType', expanded), nodeTypeIndicator);\n\n      var renderedItemString = getItemString(nodeType, data, itemType, createItemString(data, collectionLimit));\n      var stylingArgs = [keyPath, nodeType, expanded, expandable];\n      return hideRoot ? /*#__PURE__*/_react[\"default\"].createElement(\"li\", styling.apply(void 0, ['rootNode'].concat(stylingArgs)), /*#__PURE__*/_react[\"default\"].createElement(\"ul\", styling.apply(void 0, ['rootNodeChildren'].concat(stylingArgs)), renderedChildren)) : /*#__PURE__*/_react[\"default\"].createElement(\"li\", styling.apply(void 0, ['nestedNode'].concat(stylingArgs)), expandable && /*#__PURE__*/_react[\"default\"].createElement(_JSONArrow[\"default\"], {\n        styling: styling,\n        nodeType: nodeType,\n        expanded: expanded,\n        onClick: this.handleClick\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"label\", _extends({}, styling.apply(void 0, [['label', 'nestedNodeLabel']].concat(stylingArgs)), {\n        onClick: this.handleClick\n      }), labelRenderer.apply(void 0, stylingArgs)), /*#__PURE__*/_react[\"default\"].createElement(\"span\", _extends({}, styling.apply(void 0, ['nestedNodeItemString'].concat(stylingArgs)), {\n        onClick: this.handleClick\n      }), renderedItemString), /*#__PURE__*/_react[\"default\"].createElement(\"ul\", styling.apply(void 0, ['nestedNodeChildren'].concat(stylingArgs)), renderedChildren));\n    }\n  }]);\n\n  return JSONNestedNode;\n}(_react[\"default\"].Component);\n\nexports[\"default\"] = JSONNestedNode;\n\n_defineProperty(JSONNestedNode, \"propTypes\", {\n  getItemString: _propTypes[\"default\"].func.isRequired,\n  nodeTypeIndicator: _propTypes[\"default\"].any,\n  nodeType: _propTypes[\"default\"].string.isRequired,\n  data: _propTypes[\"default\"].any,\n  hideRoot: _propTypes[\"default\"].bool.isRequired,\n  createItemString: _propTypes[\"default\"].func.isRequired,\n  styling: _propTypes[\"default\"].func.isRequired,\n  collectionLimit: _propTypes[\"default\"].number,\n  keyPath: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].oneOfType([_propTypes[\"default\"].string, _propTypes[\"default\"].number])).isRequired,\n  labelRenderer: _propTypes[\"default\"].func.isRequired,\n  shouldExpandNode: _propTypes[\"default\"].func,\n  level: _propTypes[\"default\"].number.isRequired,\n  sortObjectKeys: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].func, _propTypes[\"default\"].bool]),\n  isCircular: _propTypes[\"default\"].bool,\n  expandable: _propTypes[\"default\"].bool\n});\n\n_defineProperty(JSONNestedNode, \"defaultProps\", {\n  data: [],\n  circularCache: [],\n  level: 0,\n  expandable: true\n});\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/JSONNestedNode.tsx"],"names":["isRange","rangeOrEntry","to","undefined","renderChildNodes","props","from","nodeType","data","collectionLimit","circularCache","keyPath","postprocessValue","sortObjectKeys","childNodes","forEach","entry","push","key","value","isCircular","indexOf","getStateFromProps","expanded","shouldExpandNode","level","JSONNestedNode","expandable","setState","state","nextProps","nextState","Object","keys","find","join","getItemString","nodeTypeIndicator","hideRoot","createItemString","styling","labelRenderer","renderedChildren","itemType","renderedItemString","stylingArgs","handleClick","React","Component","PropTypes","func","isRequired","any","string","bool","number","arrayOf","oneOfType"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport JSONArrow from './JSONArrow';\nimport getCollectionEntries from './getCollectionEntries';\nimport JSONNode from './JSONNode';\nimport ItemRange from './ItemRange';\nimport {\n  CircularPropsPassedThroughJSONNestedNode,\n  CircularPropsPassedThroughRenderChildNodes,\n} from './types';\n\n/**\n * Renders nested values (eg. objects, arrays, lists, etc.)\n */\n\nexport interface RenderChildNodesProps\n  extends CircularPropsPassedThroughRenderChildNodes {\n  data: any;\n  nodeType: string;\n}\n\ninterface Range {\n  from: number;\n  to: number;\n}\n\ninterface Entry {\n  key: string | number;\n  value: any;\n}\n\nfunction isRange(rangeOrEntry: Range | Entry): rangeOrEntry is Range {\n  return (rangeOrEntry as Range).to !== undefined;\n}\n\nfunction renderChildNodes(\n  props: RenderChildNodesProps,\n  from?: number,\n  to?: number\n) {\n  const {\n    nodeType,\n    data,\n    collectionLimit,\n    circularCache,\n    keyPath,\n    postprocessValue,\n    sortObjectKeys,\n  } = props;\n  const childNodes: React.ReactNode[] = [];\n\n  getCollectionEntries(\n    nodeType,\n    data,\n    sortObjectKeys,\n    collectionLimit,\n    from,\n    to\n  ).forEach((entry) => {\n    if (isRange(entry)) {\n      childNodes.push(\n        <ItemRange\n          {...props}\n          key={`ItemRange--${entry.from}-${entry.to}`}\n          from={entry.from}\n          to={entry.to}\n          renderChildNodes={renderChildNodes}\n        />\n      );\n    } else {\n      const { key, value } = entry;\n      const isCircular = circularCache.indexOf(value) !== -1;\n\n      childNodes.push(\n        <JSONNode\n          {...props}\n          {...{ postprocessValue, collectionLimit }}\n          key={`Node--${key}`}\n          keyPath={[key, ...keyPath]}\n          value={postprocessValue(value)}\n          circularCache={[...circularCache, value]}\n          isCircular={isCircular}\n          hideRoot={false}\n        />\n      );\n    }\n  });\n\n  return childNodes;\n}\n\ninterface Props extends CircularPropsPassedThroughJSONNestedNode {\n  data: any;\n  nodeType: string;\n  nodeTypeIndicator: string;\n  createItemString: (data: any, collectionLimit: number) => string;\n  expandable: boolean;\n}\n\ninterface State {\n  expanded: boolean;\n}\n\nfunction getStateFromProps(props: Props) {\n  // calculate individual node expansion if necessary\n  const expanded =\n    props.shouldExpandNode && !props.isCircular\n      ? props.shouldExpandNode(props.keyPath, props.data, props.level)\n      : false;\n  return {\n    expanded,\n  };\n}\n\nexport default class JSONNestedNode extends React.Component<Props, State> {\n  static propTypes = {\n    getItemString: PropTypes.func.isRequired,\n    nodeTypeIndicator: PropTypes.any,\n    nodeType: PropTypes.string.isRequired,\n    data: PropTypes.any,\n    hideRoot: PropTypes.bool.isRequired,\n    createItemString: PropTypes.func.isRequired,\n    styling: PropTypes.func.isRequired,\n    collectionLimit: PropTypes.number,\n    keyPath: PropTypes.arrayOf(\n      PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n    ).isRequired,\n    labelRenderer: PropTypes.func.isRequired,\n    shouldExpandNode: PropTypes.func,\n    level: PropTypes.number.isRequired,\n    sortObjectKeys: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n    isCircular: PropTypes.bool,\n    expandable: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    data: [],\n    circularCache: [],\n    level: 0,\n    expandable: true,\n  };\n\n  constructor(props: Props) {\n    super(props);\n    this.state = getStateFromProps(props);\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    const nextState = getStateFromProps(nextProps);\n    if (getStateFromProps(this.props).expanded !== nextState.expanded) {\n      this.setState(nextState);\n    }\n  }\n\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    return (\n      !!Object.keys(nextProps).find(\n        (key) =>\n          key !== 'circularCache' &&\n          (key === 'keyPath'\n            ? nextProps[key].join('/') !== this.props[key].join('/')\n            : nextProps[key as keyof Props] !== this.props[key as keyof Props])\n      ) || nextState.expanded !== this.state.expanded\n    );\n  }\n\n  render() {\n    const {\n      getItemString,\n      nodeTypeIndicator,\n      nodeType,\n      data,\n      hideRoot,\n      createItemString,\n      styling,\n      collectionLimit,\n      keyPath,\n      labelRenderer,\n      expandable,\n    } = this.props;\n    const { expanded } = this.state;\n    const renderedChildren =\n      expanded || (hideRoot && this.props.level === 0)\n        ? renderChildNodes({ ...this.props, level: this.props.level + 1 })\n        : null;\n\n    const itemType = (\n      <span {...styling('nestedNodeItemType', expanded)}>\n        {nodeTypeIndicator}\n      </span>\n    );\n    const renderedItemString = getItemString(\n      nodeType,\n      data,\n      itemType,\n      createItemString(data, collectionLimit)\n    );\n    const stylingArgs = [keyPath, nodeType, expanded, expandable] as const;\n\n    return hideRoot ? (\n      <li {...styling('rootNode', ...stylingArgs)}>\n        <ul {...styling('rootNodeChildren', ...stylingArgs)}>\n          {renderedChildren}\n        </ul>\n      </li>\n    ) : (\n      <li {...styling('nestedNode', ...stylingArgs)}>\n        {expandable && (\n          <JSONArrow\n            styling={styling}\n            nodeType={nodeType}\n            expanded={expanded}\n            onClick={this.handleClick}\n          />\n        )}\n        <label\n          {...styling(['label', 'nestedNodeLabel'], ...stylingArgs)}\n          onClick={this.handleClick}\n        >\n          {labelRenderer(...stylingArgs)}\n        </label>\n        <span\n          {...styling('nestedNodeItemString', ...stylingArgs)}\n          onClick={this.handleClick}\n        >\n          {renderedItemString}\n        </span>\n        <ul {...styling('nestedNodeChildren', ...stylingArgs)}>\n          {renderedChildren}\n        </ul>\n      </li>\n    );\n  }\n\n  handleClick = () => {\n    if (this.props.expandable) {\n      this.setState({ expanded: !this.state.expanded });\n    }\n  };\n}\n"]}},"error":null,"hash":"836ca359c60ec9416e53d737018d374c","cacheData":{"env":{}}}