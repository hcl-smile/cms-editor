{"id":"../node_modules/react-json-tree/lib/getCollectionEntries.js","dependencies":[{"name":"/usr/local/work/amis-editor/package.json","includedInParent":true,"mtime":1607074594934},{"name":"/usr/local/work/amis-editor/node_modules/react-json-tree/package.json","includedInParent":true,"mtime":1606632417569}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = getCollectionEntries;\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction getLength(type, collection) {\n  if (type === 'Object') {\n    return Object.keys(collection).length;\n  } else if (type === 'Array') {\n    return collection.length;\n  }\n\n  return Infinity;\n}\n\nfunction isIterableMap(collection) {\n  return typeof collection.set === 'function';\n}\n\nfunction getEntries(type, collection, sortObjectKeys) {\n  var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n  var res;\n\n  if (type === 'Object') {\n    var keys = Object.getOwnPropertyNames(collection);\n\n    if (sortObjectKeys) {\n      keys.sort(sortObjectKeys === true ? undefined : sortObjectKeys);\n    }\n\n    keys = keys.slice(from, to + 1);\n    res = {\n      entries: keys.map(function (key) {\n        return {\n          key: key,\n          value: collection[key]\n        };\n      })\n    };\n  } else if (type === 'Array') {\n    res = {\n      entries: collection.slice(from, to + 1).map(function (val, idx) {\n        return {\n          key: idx + from,\n          value: val\n        };\n      })\n    };\n  } else {\n    var idx = 0;\n    var entries = [];\n    var done = true;\n    var isMap = isIterableMap(collection);\n\n    var _iterator = _createForOfIteratorHelper(collection),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (idx > to) {\n          done = false;\n          break;\n        }\n\n        if (from <= idx) {\n          if (isMap && Array.isArray(item)) {\n            if (typeof item[0] === 'string' || typeof item[0] === 'number') {\n              entries.push({\n                key: item[0],\n                value: item[1]\n              });\n            } else {\n              entries.push({\n                key: \"[entry \".concat(idx, \"]\"),\n                value: {\n                  '[key]': item[0],\n                  '[value]': item[1]\n                }\n              });\n            }\n          } else {\n            entries.push({\n              key: idx,\n              value: item\n            });\n          }\n        }\n\n        idx++;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    res = {\n      hasMore: !done,\n      entries: entries\n    };\n  }\n\n  return res;\n}\n\nfunction getRanges(from, to, limit) {\n  var ranges = [];\n\n  while (to - from > limit * limit) {\n    limit = limit * limit;\n  }\n\n  for (var i = from; i <= to; i += limit) {\n    ranges.push({\n      from: i,\n      to: Math.min(to, i + limit - 1)\n    });\n  }\n\n  return ranges;\n}\n\nfunction getCollectionEntries(type, collection, sortObjectKeys, limit) {\n  var from = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var to = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n  var getEntriesBound = getEntries.bind(null, type, collection, sortObjectKeys);\n\n  if (!limit) {\n    return getEntriesBound().entries;\n  }\n\n  var isSubset = to < Infinity;\n  var length = Math.min(to - from, getLength(type, collection));\n\n  if (type !== 'Iterable') {\n    if (length <= limit || limit < 7) {\n      return getEntriesBound(from, to).entries;\n    }\n  } else {\n    if (length <= limit && !isSubset) {\n      return getEntriesBound(from, to).entries;\n    }\n  }\n\n  var limitedEntries;\n\n  if (type === 'Iterable') {\n    var _getEntriesBound = getEntriesBound(from, from + limit - 1),\n        hasMore = _getEntriesBound.hasMore,\n        entries = _getEntriesBound.entries;\n\n    limitedEntries = hasMore ? [].concat(_toConsumableArray(entries), _toConsumableArray(getRanges(from + limit, from + 2 * limit - 1, limit))) : entries;\n  } else {\n    limitedEntries = isSubset ? getRanges(from, to, limit) : [].concat(_toConsumableArray(getEntriesBound(0, limit - 5).entries), _toConsumableArray(getRanges(limit - 4, length - 5, limit)), _toConsumableArray(getEntriesBound(length - 4, length - 1).entries));\n  }\n\n  return limitedEntries;\n}\n"},"sourceMaps":{"js":{"version":3,"sources":["../src/getCollectionEntries.ts"],"names":["getLength","type","collection","Object","keys","length","Infinity","isIterableMap","set","getEntries","sortObjectKeys","from","to","res","getOwnPropertyNames","sort","undefined","slice","entries","map","key","value","val","idx","done","isMap","item","Array","isArray","push","hasMore","getRanges","limit","ranges","i","Math","min","getCollectionEntries","getEntriesBound","bind","isSubset","limitedEntries"],"mappings":"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","sourcesContent":["function getLength(type: string, collection: any) {\n  if (type === 'Object') {\n    return Object.keys(collection).length;\n  } else if (type === 'Array') {\n    return (collection as unknown[]).length;\n  }\n\n  return Infinity;\n}\n\nfunction isIterableMap(collection: any) {\n  return typeof (collection as Map<any, any>).set === 'function';\n}\n\nfunction getEntries(\n  type: string,\n  collection: any,\n  sortObjectKeys?: ((a: any, b: any) => number) | boolean | undefined,\n  from = 0,\n  to = Infinity\n): { entries: { key: string | number; value: any }[]; hasMore?: boolean } {\n  let res;\n\n  if (type === 'Object') {\n    let keys = Object.getOwnPropertyNames(collection);\n\n    if (sortObjectKeys) {\n      keys.sort(sortObjectKeys === true ? undefined : sortObjectKeys);\n    }\n\n    keys = keys.slice(from, to + 1);\n\n    res = {\n      entries: keys.map((key) => ({ key, value: collection[key] })),\n    };\n  } else if (type === 'Array') {\n    res = {\n      entries: collection\n        .slice(from, to + 1)\n        .map((val: unknown, idx: number) => ({ key: idx + from, value: val })),\n    };\n  } else {\n    let idx = 0;\n    const entries = [];\n    let done = true;\n\n    const isMap = isIterableMap(collection);\n\n    for (const item of collection) {\n      if (idx > to) {\n        done = false;\n        break;\n      }\n      if (from <= idx) {\n        if (isMap && Array.isArray(item)) {\n          if (typeof item[0] === 'string' || typeof item[0] === 'number') {\n            entries.push({ key: item[0], value: item[1] });\n          } else {\n            entries.push({\n              key: `[entry ${idx}]`,\n              value: {\n                '[key]': item[0],\n                '[value]': item[1],\n              },\n            });\n          }\n        } else {\n          entries.push({ key: idx, value: item });\n        }\n      }\n      idx++;\n    }\n\n    res = {\n      hasMore: !done,\n      entries,\n    };\n  }\n\n  return res;\n}\n\nfunction getRanges(from: number, to: number, limit: number) {\n  const ranges = [];\n  while (to - from > limit * limit) {\n    limit = limit * limit;\n  }\n  for (let i = from; i <= to; i += limit) {\n    ranges.push({ from: i, to: Math.min(to, i + limit - 1) });\n  }\n\n  return ranges;\n}\n\nexport default function getCollectionEntries(\n  type: string,\n  collection: any,\n  sortObjectKeys: ((a: any, b: any) => number) | boolean | undefined,\n  limit: number,\n  from = 0,\n  to = Infinity\n) {\n  const getEntriesBound = getEntries.bind(\n    null,\n    type,\n    collection,\n    sortObjectKeys\n  );\n\n  if (!limit) {\n    return getEntriesBound().entries;\n  }\n\n  const isSubset = to < Infinity;\n  const length = Math.min(to - from, getLength(type, collection));\n\n  if (type !== 'Iterable') {\n    if (length <= limit || limit < 7) {\n      return getEntriesBound(from, to).entries;\n    }\n  } else {\n    if (length <= limit && !isSubset) {\n      return getEntriesBound(from, to).entries;\n    }\n  }\n\n  let limitedEntries;\n  if (type === 'Iterable') {\n    const { hasMore, entries } = getEntriesBound(from, from + limit - 1);\n\n    limitedEntries = hasMore\n      ? [...entries, ...getRanges(from + limit, from + 2 * limit - 1, limit)]\n      : entries;\n  } else {\n    limitedEntries = isSubset\n      ? getRanges(from, to, limit)\n      : [\n          ...getEntriesBound(0, limit - 5).entries,\n          ...getRanges(limit - 4, length - 5, limit),\n          ...getEntriesBound(length - 4, length - 1).entries,\n        ];\n  }\n\n  return limitedEntries;\n}\n"]}},"error":null,"hash":"c05896965e56070ab45cf9a701c11196","cacheData":{"env":{}}}