{"id":"../node_modules/mobx-react/dist/mobxreact.esm.js","dependencies":[{"name":"/usr/local/work/amis-editor/node_modules/mobx-react/dist/mobxreact.esm.js.map","includedInParent":true,"mtime":1607059625592},{"name":"/usr/local/work/amis-editor/package.json","includedInParent":true,"mtime":1607074594934},{"name":"/usr/local/work/amis-editor/node_modules/mobx-react/package.json","includedInParent":true,"mtime":1607059625592},{"name":"mobx","loc":{"line":1,"column":198},"parent":"/usr/local/work/amis-editor/node_modules/mobx-react/dist/mobxreact.esm.js","resolved":"/usr/local/work/amis-editor/node_modules/mobx/lib/mobx.module.js"},{"name":"react","loc":{"line":2,"column":90},"parent":"/usr/local/work/amis-editor/node_modules/mobx-react/dist/mobxreact.esm.js","resolved":"/usr/local/work/amis-editor/node_modules/react/index.js"},{"name":"react-dom","loc":{"line":3,"column":40},"parent":"/usr/local/work/amis-editor/node_modules/mobx-react/dist/mobxreact.esm.js","resolved":"/usr/local/work/amis-editor/node_modules/react-dom/index.js"},{"name":"mobx-react-lite","loc":{"line":5,"column":120},"parent":"/usr/local/work/amis-editor/node_modules/mobx-react/dist/mobxreact.esm.js","resolved":"/usr/local/work/amis-editor/node_modules/mobx-react-lite/dist/index.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Provider = Provider;\nexports.disposeOnUnmount = disposeOnUnmount;\nexports.inject = inject;\nexports.observer = observer;\nObject.defineProperty(exports, \"Observer\", {\n  enumerable: true,\n  get: function () {\n    return _mobxReactLite.Observer;\n  }\n});\nObject.defineProperty(exports, \"isUsingStaticRendering\", {\n  enumerable: true,\n  get: function () {\n    return _mobxReactLite.isUsingStaticRendering;\n  }\n});\nObject.defineProperty(exports, \"useAsObservableSource\", {\n  enumerable: true,\n  get: function () {\n    return _mobxReactLite.useAsObservableSource;\n  }\n});\nObject.defineProperty(exports, \"useLocalStore\", {\n  enumerable: true,\n  get: function () {\n    return _mobxReactLite.useLocalStore;\n  }\n});\nObject.defineProperty(exports, \"useObserver\", {\n  enumerable: true,\n  get: function () {\n    return _mobxReactLite.useObserver;\n  }\n});\nObject.defineProperty(exports, \"useStaticRendering\", {\n  enumerable: true,\n  get: function () {\n    return _mobxReactLite.useStaticRendering;\n  }\n});\nexports.PropTypes = exports.MobXProviderContext = void 0;\n\nvar _mobx = require(\"mobx\");\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _reactDom = require(\"react-dom\");\n\nvar _mobxReactLite = require(\"mobx-react-lite\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nlet symbolId = 0;\n\nfunction createSymbol(name) {\n  if (typeof Symbol === \"function\") {\n    return Symbol(name);\n  }\n\n  const symbol = `__$mobx-react ${name} (${symbolId})`;\n  symbolId++;\n  return symbol;\n}\n\nconst createdSymbols = {};\n\nfunction newSymbol(name) {\n  if (!createdSymbols[name]) {\n    createdSymbols[name] = createSymbol(name);\n  }\n\n  return createdSymbols[name];\n}\n\nfunction shallowEqual(objA, objB) {\n  //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n} // based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\n\n\nconst hoistBlackList = {\n  $$typeof: 1,\n  render: 1,\n  compare: 1,\n  type: 1,\n  childContextTypes: 1,\n  contextType: 1,\n  contextTypes: 1,\n  defaultProps: 1,\n  getDefaultProps: 1,\n  getDerivedStateFromError: 1,\n  getDerivedStateFromProps: 1,\n  mixins: 1,\n  propTypes: 1\n};\n\nfunction copyStaticProperties(base, target) {\n  const protoProps = Object.getOwnPropertyNames(Object.getPrototypeOf(base));\n  Object.getOwnPropertyNames(base).forEach(key => {\n    if (!hoistBlackList[key] && protoProps.indexOf(key) === -1) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}\n/**\r\n * Helper to set `prop` to `this` as non-enumerable (hidden prop)\r\n * @param target\r\n * @param prop\r\n * @param value\r\n */\n\n\nfunction setHiddenProp(target, prop, value) {\n  if (!Object.hasOwnProperty.call(target, prop)) {\n    Object.defineProperty(target, prop, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value\n    });\n  } else {\n    target[prop] = value;\n  }\n}\n/**\r\n * Utilities for patching componentWillUnmount, to make sure @disposeOnUnmount works correctly icm with user defined hooks\r\n * and the handler provided by mobx-react\r\n */\n\n\nconst mobxMixins = /*#__PURE__*/newSymbol(\"patchMixins\");\nconst mobxPatchedDefinition = /*#__PURE__*/newSymbol(\"patchedDefinition\");\n\nfunction getMixins(target, methodName) {\n  const mixins = target[mobxMixins] = target[mobxMixins] || {};\n  const methodMixins = mixins[methodName] = mixins[methodName] || {};\n  methodMixins.locks = methodMixins.locks || 0;\n  methodMixins.methods = methodMixins.methods || [];\n  return methodMixins;\n}\n\nfunction wrapper(realMethod, mixins, ...args) {\n  // locks are used to ensure that mixins are invoked only once per invocation, even on recursive calls\n  mixins.locks++;\n\n  try {\n    let retVal;\n\n    if (realMethod !== undefined && realMethod !== null) {\n      retVal = realMethod.apply(this, args);\n    }\n\n    return retVal;\n  } finally {\n    mixins.locks--;\n\n    if (mixins.locks === 0) {\n      mixins.methods.forEach(mx => {\n        mx.apply(this, args);\n      });\n    }\n  }\n}\n\nfunction wrapFunction(realMethod, mixins) {\n  const fn = function (...args) {\n    wrapper.call(this, realMethod, mixins, ...args);\n  };\n\n  return fn;\n}\n\nfunction patch(target, methodName, mixinMethod) {\n  const mixins = getMixins(target, methodName);\n\n  if (mixins.methods.indexOf(mixinMethod) < 0) {\n    mixins.methods.push(mixinMethod);\n  }\n\n  const oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);\n\n  if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {\n    // already patched definition, do not repatch\n    return;\n  }\n\n  const originalMethod = target[methodName];\n  const newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : undefined, mixins, originalMethod);\n  Object.defineProperty(target, methodName, newDefinition);\n}\n\nfunction createDefinition(target, methodName, enumerable, mixins, originalMethod) {\n  let wrappedFunc = wrapFunction(originalMethod, mixins);\n  return {\n    [mobxPatchedDefinition]: true,\n    get: function () {\n      return wrappedFunc;\n    },\n    set: function (value) {\n      if (this === target) {\n        wrappedFunc = wrapFunction(value, mixins);\n      } else {\n        // when it is an instance of the prototype/a child prototype patch that particular case again separately\n        // since we need to store separate values depending on wether it is the actual instance, the prototype, etc\n        // e.g. the method for super might not be the same as the method for the prototype which might be not the same\n        // as the method for the instance\n        const newDefinition = createDefinition(this, methodName, enumerable, mixins, value);\n        Object.defineProperty(this, methodName, newDefinition);\n      }\n    },\n    configurable: true,\n    enumerable: enumerable\n  };\n}\n\nconst mobxAdminProperty = _mobx.$mobx || \"$mobx\";\nconst mobxIsUnmounted = /*#__PURE__*/newSymbol(\"isUnmounted\");\nconst skipRenderKey = /*#__PURE__*/newSymbol(\"skipRender\");\nconst isForcingUpdateKey = /*#__PURE__*/newSymbol(\"isForcingUpdate\");\n\nfunction makeClassComponentObserver(componentClass) {\n  const target = componentClass.prototype;\n  if (target.componentWillReact) throw new Error(\"The componentWillReact life-cycle event is no longer supported\");\n\n  if (componentClass[\"__proto__\"] !== _react.PureComponent) {\n    if (!target.shouldComponentUpdate) target.shouldComponentUpdate = observerSCU;else if (target.shouldComponentUpdate !== observerSCU) // n.b. unequal check, instead of existence check, as @observer might be on superclass as well\n      throw new Error(\"It is not allowed to use shouldComponentUpdate in observer based components.\");\n  } // this.props and this.state are made observable, just to make sure @computed fields that\n  // are defined inside the component, and which rely on state or props, re-compute if state or props change\n  // (otherwise the computed wouldn't update and become stale on props change, since props are not observable)\n  // However, this solution is not without it's own problems: https://github.com/mobxjs/mobx-react/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aobservable-props-or-not+\n\n\n  makeObservableProp(target, \"props\");\n  makeObservableProp(target, \"state\");\n  const baseRender = target.render;\n\n  target.render = function () {\n    return makeComponentReactive.call(this, baseRender);\n  };\n\n  patch(target, \"componentWillUnmount\", function () {\n    if ((0, _mobxReactLite.isUsingStaticRendering)() === true) return;\n\n    if (this.render[mobxAdminProperty]) {\n      this.render[mobxAdminProperty].dispose();\n    } else if (\"development\" !== \"production\") {\n      const displayName = getDisplayName(this);\n      console.warn(`The render function for an observer component (${displayName}) was modified after MobX attached. This is not supported, since the new function can't be triggered by MobX.`);\n    }\n\n    this[mobxIsUnmounted] = true;\n  });\n  return componentClass;\n} // Generates a friendly name for debugging\n\n\nfunction getDisplayName(comp) {\n  return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || \"<component>\";\n}\n\nfunction makeComponentReactive(render) {\n  if ((0, _mobxReactLite.isUsingStaticRendering)() === true) return render.call(this);\n  /**\r\n   * If props are shallowly modified, react will render anyway,\r\n   * so atom.reportChanged() should not result in yet another re-render\r\n   */\n\n  setHiddenProp(this, skipRenderKey, false);\n  /**\r\n   * forceUpdate will re-assign this.props. We don't want that to cause a loop,\r\n   * so detect these changes\r\n   */\n\n  setHiddenProp(this, isForcingUpdateKey, false);\n  const initialName = getDisplayName(this);\n  const baseRender = render.bind(this);\n  let isRenderingPending = false;\n  const reaction = new _mobx.Reaction(`${initialName}.render()`, () => {\n    if (!isRenderingPending) {\n      // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)\n      // This unidiomatic React usage but React will correctly warn about this so we continue as usual\n      // See #85 / Pull #44\n      isRenderingPending = true;\n\n      if (this[mobxIsUnmounted] !== true) {\n        let hasError = true;\n\n        try {\n          setHiddenProp(this, isForcingUpdateKey, true);\n          if (!this[skipRenderKey]) _react.Component.prototype.forceUpdate.call(this);\n          hasError = false;\n        } finally {\n          setHiddenProp(this, isForcingUpdateKey, false);\n          if (hasError) reaction.dispose();\n        }\n      }\n    }\n  });\n  reaction[\"reactComponent\"] = this;\n  reactiveRender[mobxAdminProperty] = reaction;\n  this.render = reactiveRender;\n\n  function reactiveRender() {\n    isRenderingPending = false;\n    let exception = undefined;\n    let rendering = undefined;\n    reaction.track(() => {\n      try {\n        rendering = (0, _mobx._allowStateChanges)(false, baseRender);\n      } catch (e) {\n        exception = e;\n      }\n    });\n\n    if (exception) {\n      throw exception;\n    }\n\n    return rendering;\n  }\n\n  return reactiveRender.call(this);\n}\n\nfunction observerSCU(nextProps, nextState) {\n  if ((0, _mobxReactLite.isUsingStaticRendering)()) {\n    console.warn(\"[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\");\n  } // update on any state changes (as is the default)\n\n\n  if (this.state !== nextState) {\n    return true;\n  } // update if props are shallowly not equal, inspired by PureRenderMixin\n  // we could return just 'false' here, and avoid the `skipRender` checks etc\n  // however, it is nicer if lifecycle events are triggered like usually,\n  // so we return true here if props are shallowly modified.\n\n\n  return !shallowEqual(this.props, nextProps);\n}\n\nfunction makeObservableProp(target, propName) {\n  const valueHolderKey = newSymbol(`reactProp_${propName}_valueHolder`);\n  const atomHolderKey = newSymbol(`reactProp_${propName}_atomHolder`);\n\n  function getAtom() {\n    if (!this[atomHolderKey]) {\n      setHiddenProp(this, atomHolderKey, (0, _mobx.createAtom)(\"reactive \" + propName));\n    }\n\n    return this[atomHolderKey];\n  }\n\n  Object.defineProperty(target, propName, {\n    configurable: true,\n    enumerable: true,\n    get: function () {\n      let prevReadState = false;\n\n      if (_mobx._allowStateReadsStart && _mobx._allowStateReadsEnd) {\n        prevReadState = (0, _mobx._allowStateReadsStart)(true);\n      }\n\n      getAtom.call(this).reportObserved();\n\n      if (_mobx._allowStateReadsStart && _mobx._allowStateReadsEnd) {\n        (0, _mobx._allowStateReadsEnd)(prevReadState);\n      }\n\n      return this[valueHolderKey];\n    },\n    set: function set(v) {\n      if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v)) {\n        setHiddenProp(this, valueHolderKey, v);\n        setHiddenProp(this, skipRenderKey, true);\n        getAtom.call(this).reportChanged();\n        setHiddenProp(this, skipRenderKey, false);\n      } else {\n        setHiddenProp(this, valueHolderKey, v);\n      }\n    }\n  });\n}\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for; // Using react-is had some issues (and operates on elements, not on types), see #608 / #609\n\nconst ReactForwardRefSymbol = hasSymbol ? /*#__PURE__*/Symbol.for(\"react.forward_ref\") : typeof _react.forwardRef === \"function\" && /*#__PURE__*/(0, _react.forwardRef)(props => null)[\"$$typeof\"];\nconst ReactMemoSymbol = hasSymbol ? /*#__PURE__*/Symbol.for(\"react.memo\") : typeof _react.memo === \"function\" && /*#__PURE__*/(0, _react.memo)(props => null)[\"$$typeof\"];\n/**\r\n * Observer function / decorator\r\n */\n\nfunction observer(component) {\n  if (component[\"isMobxInjector\"] === true) {\n    console.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\");\n  }\n\n  if (ReactMemoSymbol && component[\"$$typeof\"] === ReactMemoSymbol) {\n    throw new Error(\"Mobx observer: You are trying to use 'observer' on function component wrapped to either another observer or 'React.memo'. The observer already applies 'React.memo' for you.\");\n  } // Unwrap forward refs into `<Observer>` component\n  // we need to unwrap the render, because it is the inner render that needs to be tracked,\n  // not the ForwardRef HoC\n\n\n  if (ReactForwardRefSymbol && component[\"$$typeof\"] === ReactForwardRefSymbol) {\n    const baseRender = component[\"render\"];\n    if (typeof baseRender !== \"function\") throw new Error(\"render property of ForwardRef was not a function\");\n    return (0, _react.forwardRef)(function ObserverForwardRef() {\n      return (0, _react.createElement)(_mobxReactLite.Observer, null, () => baseRender.apply(undefined, arguments));\n    });\n  } // Function component\n\n\n  if (typeof component === \"function\" && (!component.prototype || !component.prototype.render) && !component[\"isReactClass\"] && !Object.prototype.isPrototypeOf.call(_react.Component, component)) {\n    return (0, _mobxReactLite.observer)(component);\n  }\n\n  return makeClassComponentObserver(component);\n}\n\nconst MobXProviderContext = /*#__PURE__*/_react.default.createContext({});\n\nexports.MobXProviderContext = MobXProviderContext;\n\nfunction Provider(props) {\n  const {\n    children,\n    ...stores\n  } = props;\n\n  const parentValue = _react.default.useContext(MobXProviderContext);\n\n  const mutableProviderRef = _react.default.useRef({ ...parentValue,\n    ...stores\n  });\n\n  const value = mutableProviderRef.current;\n\n  if (\"development\" !== \"production\") {\n    const newValue = { ...value,\n      ...stores\n    }; // spread in previous state for the context based stores\n\n    if (!shallowEqual(value, newValue)) {\n      throw new Error(\"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\");\n    }\n  }\n\n  return _react.default.createElement(MobXProviderContext.Provider, {\n    value: value\n  }, children);\n}\n\nProvider.displayName = \"MobXProvider\";\n/**\r\n * Store Injection\r\n */\n\nfunction createStoreInjector(grabStoresFn, component, injectNames, makeReactive) {\n  // Support forward refs\n  let Injector = _react.default.forwardRef((props, ref) => {\n    const newProps = { ...props\n    };\n\n    const context = _react.default.useContext(MobXProviderContext);\n\n    Object.assign(newProps, grabStoresFn(context || {}, newProps) || {});\n\n    if (ref) {\n      newProps.ref = ref;\n    }\n\n    return _react.default.createElement(component, newProps);\n  });\n\n  if (makeReactive) Injector = observer(Injector);\n  Injector[\"isMobxInjector\"] = true; // assigned late to suppress observer warning\n  // Static fields from component should be visible on the generated Injector\n\n  copyStaticProperties(component, Injector);\n  Injector[\"wrappedComponent\"] = component;\n  Injector.displayName = getInjectName(component, injectNames);\n  return Injector;\n}\n\nfunction getInjectName(component, injectNames) {\n  let displayName;\n  const componentName = component.displayName || component.name || component.constructor && component.constructor.name || \"Component\";\n  if (injectNames) displayName = \"inject-with-\" + injectNames + \"(\" + componentName + \")\";else displayName = \"inject(\" + componentName + \")\";\n  return displayName;\n}\n\nfunction grabStoresByName(storeNames) {\n  return function (baseStores, nextProps) {\n    storeNames.forEach(function (storeName) {\n      if (storeName in nextProps // prefer props over stores\n      ) return;\n      if (!(storeName in baseStores)) throw new Error(\"MobX injector: Store '\" + storeName + \"' is not available! Make sure it is provided by some Provider\");\n      nextProps[storeName] = baseStores[storeName];\n    });\n    return nextProps;\n  };\n}\n/**\r\n * higher order component that injects stores to a child.\r\n * takes either a varargs list of strings, which are stores read from the context,\r\n * or a function that manually maps the available stores from the context to props:\r\n * storesToProps(mobxStores, props, context) => newProps\r\n */\n\n\nfunction inject(\n/* fn(stores, nextProps) or ...storeNames */\n...storeNames) {\n  if (typeof arguments[0] === \"function\") {\n    let grabStoresFn = arguments[0];\n    return componentClass => createStoreInjector(grabStoresFn, componentClass, grabStoresFn.name, true);\n  } else {\n    return componentClass => createStoreInjector(grabStoresByName(storeNames), componentClass, storeNames.join(\"-\"), false);\n  }\n}\n\nconst protoStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountProto\");\nconst instStoreKey = /*#__PURE__*/newSymbol(\"disposeOnUnmountInst\");\n\nfunction runDisposersOnWillUnmount() {\n  [...(this[protoStoreKey] || []), ...(this[instStoreKey] || [])].forEach(propKeyOrFunction => {\n    const prop = typeof propKeyOrFunction === \"string\" ? this[propKeyOrFunction] : propKeyOrFunction;\n\n    if (prop !== undefined && prop !== null) {\n      if (Array.isArray(prop)) prop.map(f => f());else prop();\n    }\n  });\n}\n\nfunction disposeOnUnmount(target, propertyKeyOrFunction) {\n  if (Array.isArray(propertyKeyOrFunction)) {\n    return propertyKeyOrFunction.map(fn => disposeOnUnmount(target, fn));\n  }\n\n  const c = Object.getPrototypeOf(target).constructor || Object.getPrototypeOf(target.constructor);\n  const c2 = Object.getPrototypeOf(target.constructor);\n\n  if (!(c === _react.default.Component || c === _react.default.PureComponent || c2 === _react.default.Component || c2 === _react.default.PureComponent)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.\");\n  }\n\n  if (typeof propertyKeyOrFunction !== \"string\" && typeof propertyKeyOrFunction !== \"function\" && !Array.isArray(propertyKeyOrFunction)) {\n    throw new Error(\"[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.\");\n  } // decorator's target is the prototype, so it doesn't have any instance properties like props\n\n\n  const isDecorator = typeof propertyKeyOrFunction === \"string\"; // add property key / function we want run (disposed) to the store\n\n  const componentWasAlreadyModified = !!target[protoStoreKey] || !!target[instStoreKey];\n  const store = isDecorator ? // decorators are added to the prototype store\n  target[protoStoreKey] || (target[protoStoreKey] = []) : // functions are added to the instance store\n  target[instStoreKey] || (target[instStoreKey] = []);\n  store.push(propertyKeyOrFunction); // tweak the component class componentWillUnmount if not done already\n\n  if (!componentWasAlreadyModified) {\n    patch(target, \"componentWillUnmount\", runDisposersOnWillUnmount);\n  } // return the disposer as is if invoked as a non decorator\n\n\n  if (typeof propertyKeyOrFunction !== \"string\") {\n    return propertyKeyOrFunction;\n  }\n}\n\nfunction createChainableTypeChecker(validator) {\n  function checkType(isRequired, props, propName, componentName, location, propFullName, ...rest) {\n    return (0, _mobx.untracked)(() => {\n      componentName = componentName || \"<<anonymous>>\";\n      propFullName = propFullName || propName;\n\n      if (props[propName] == null) {\n        if (isRequired) {\n          const actual = props[propName] === null ? \"null\" : \"undefined\";\n          return new Error(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + \"in `\" + componentName + \"`, but its value is `\" + actual + \"`.\");\n        }\n\n        return null;\n      } else {\n        // @ts-ignore rest arg is necessary for some React internals - fails tests otherwise\n        return validator(props, propName, componentName, location, propFullName, ...rest);\n      }\n    });\n  }\n\n  const chainedCheckType = checkType.bind(null, false); // Add isRequired to satisfy Requirable\n\n  chainedCheckType.isRequired = checkType.bind(null, true);\n  return chainedCheckType;\n} // Copied from React.PropTypes\n\n\nfunction isSymbol(propType, propValue) {\n  // Native Symbol.\n  if (propType === \"symbol\") {\n    return true;\n  } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n\n\n  if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n    return true;\n  } // Fallback for non-spec compliant Symbols which are polyfilled.\n\n\n  if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n    return true;\n  }\n\n  return false;\n} // Copied from React.PropTypes\n\n\nfunction getPropType(propValue) {\n  const propType = typeof propValue;\n\n  if (Array.isArray(propValue)) {\n    return \"array\";\n  }\n\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return \"object\";\n  }\n\n  if (isSymbol(propType, propValue)) {\n    return \"symbol\";\n  }\n\n  return propType;\n} // This handles more types than `getPropType`. Only used for error messages.\n// Copied from React.PropTypes\n\n\nfunction getPreciseType(propValue) {\n  const propType = getPropType(propValue);\n\n  if (propType === \"object\") {\n    if (propValue instanceof Date) {\n      return \"date\";\n    } else if (propValue instanceof RegExp) {\n      return \"regexp\";\n    }\n  }\n\n  return propType;\n}\n\nfunction createObservableTypeCheckerCreator(allowNativeType, mobxType) {\n  return createChainableTypeChecker((props, propName, componentName, location, propFullName) => {\n    return (0, _mobx.untracked)(() => {\n      if (allowNativeType) {\n        if (getPropType(props[propName]) === mobxType.toLowerCase()) return null;\n      }\n\n      let mobxChecker;\n\n      switch (mobxType) {\n        case \"Array\":\n          mobxChecker = _mobx.isObservableArray;\n          break;\n\n        case \"Object\":\n          mobxChecker = _mobx.isObservableObject;\n          break;\n\n        case \"Map\":\n          mobxChecker = _mobx.isObservableMap;\n          break;\n\n        default:\n          throw new Error(`Unexpected mobxType: ${mobxType}`);\n      }\n\n      const propValue = props[propName];\n\n      if (!mobxChecker(propValue)) {\n        const preciseType = getPreciseType(propValue);\n        const nativeTypeExpectationMessage = allowNativeType ? \" or javascript `\" + mobxType.toLowerCase() + \"`\" : \"\";\n        return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + preciseType + \"` supplied to\" + \" `\" + componentName + \"`, expected `mobx.Observable\" + mobxType + \"`\" + nativeTypeExpectationMessage + \".\");\n      }\n\n      return null;\n    });\n  });\n}\n\nfunction createObservableArrayOfTypeChecker(allowNativeType, typeChecker) {\n  return createChainableTypeChecker((props, propName, componentName, location, propFullName, ...rest) => {\n    return (0, _mobx.untracked)(() => {\n      if (typeof typeChecker !== \"function\") {\n        return new Error(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has \" + \"invalid PropType notation.\");\n      } else {\n        let error = createObservableTypeCheckerCreator(allowNativeType, \"Array\")(props, propName, componentName, location, propFullName);\n        if (error instanceof Error) return error;\n        const propValue = props[propName];\n\n        for (let i = 0; i < propValue.length; i++) {\n          error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ...rest);\n          if (error instanceof Error) return error;\n        }\n\n        return null;\n      }\n    });\n  });\n}\n\nconst observableArray = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Array\");\nconst observableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, false);\nconst observableMap = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Map\");\nconst observableObject = /*#__PURE__*/createObservableTypeCheckerCreator(false, \"Object\");\nconst arrayOrObservableArray = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Array\");\nconst arrayOrObservableArrayOf = /*#__PURE__*/createObservableArrayOfTypeChecker.bind(null, true);\nconst objectOrObservableObject = /*#__PURE__*/createObservableTypeCheckerCreator(true, \"Object\");\nconst PropTypes = {\n  observableArray,\n  observableArrayOf,\n  observableMap,\n  observableObject,\n  arrayOrObservableArray,\n  arrayOrObservableArrayOf,\n  objectOrObservableObject\n};\nexports.PropTypes = PropTypes;\nif (!_react.Component) throw new Error(\"mobx-react requires React to be available\");\nif (!_mobx.observable) throw new Error(\"mobx-react requires mobx to be available\");\nif (typeof _reactDom.unstable_batchedUpdates === \"function\") (0, _mobx.configure)({\n  reactionScheduler: _reactDom.unstable_batchedUpdates\n});"},"sourceMaps":{"js":{"mappings":[],"sources":{},"lineCount":null}},"error":null,"hash":"4370b0d04ebf1a1fe0b87d336f4fa24a","cacheData":{"env":{"NODE_ENV":"development"}}}